#——————————————————————————————————————————————————————————————————
# ███╗   ███╗███████╗ ██████╗ █████╗ ██████╗ ┌───────────────────────────┐
# ████╗ ████║██╔════╝██╔════╝██╔══██╗██╔══██╗ mescr modules             
# ██╔████╔██║█████╗  ╚█████╗ ██║  ╚═╝██████╔╝ not lisensed              
# ██║╚██╔╝██║██╔══╝   ╚═══██╗██║  ██╗██╔══██╗ https://t.me/mescr_m      
# ██║ ╚═╝ ██║███████╗██████╔╝╚█████╔╝██║  ██║└───────────────────────────┘
# ╚═╝     ╚═╝╚══════╝╚═════╝  ╚════╝ ╚═╝  ╚═╝  
#——————————————————————————————————————————————————————————————————
#┌──────────────────────────┐
# meta developer: @mescr_m
#└──────────────────────────┘
#┌───────────────────────────┐
# idea:             
# thanks:                   
#└───────────────────────────┘
#——————————————————————————————————————————————————————————————————

from .. import loader, utils # Импортируем стандартные библиотеки из внутренней директории. Без них написать модуль под Hikka будет значительно сложнее.
import asyncio
import random

__version__ = (1,2,3,4,5,6,7,8,9,0) # Таким образом мы можем указать версию нашего модуля

# Добро пожаловать в этот модуль, тут я постораюсь показать некоторые функции, которые могут вам пригодиться в написании своих модулей под Hikka Userbot.
# Писать будем под два языка: Русский и Английский. Я не буду бъяснять сам python, а затронем лишь саму структуру модулей. Приятного чтения.

@loader.tds # Делаем это, чтобы наш модуль мог автоматически переводиться
class NullMod(loader.Module):
    '''A module that will serve as an example for other people to write modules for Hikka Userbot\nDeveloper^ @mescr_m''' # Описание модуля на англ языке (если перевода не будет, это описание будет на любом языке)

    strings = {
        'name': 'NullMod', # Указываем тут название, которое будут видеть люди при использовании модуля
        'random_int': 'Should I output a random number in the command?', # Задаем описание конфигу
        'text1': 'This command is in NullMod',
        'text2': 'Since a random number is included in the config, I will output it to you: ',
        'text3': 'By the way, I replied to a message from a person whose ID is: {user_id}',
        'text4': 'The module was made by the @mescr_m channel and I wish you good luck in writing your modules :)',
        'text5': "It doesn't seem to be the first time I've done this..."
    }

    strings_ru = { # Строки на русском языке. Юзербот автоматически будет выбирать строки с нужным языком в завимости от того, какой язык выбран у пользователя
        '_cls_doc': 'Модуль, который послужит другим людям примером написания модулей под Hikka Userbot', # Задаем описание для модуля на русском языке
        'random_int': 'Выводить ли случайное число в команде?', # Задаем описание конфигу на русском языке
        'text1': 'Эта команда в NullMod', # Теперь задаем переводы английским строкам, чтобы наш модуль могли читать россияне!
        'text2': 'Поскольку в конфиге включено случайное число, то я вам его выведу: ',
        'text3': 'Кстати, я ответил на сообщение человека, чье ID: {user_id}',
        'text4': 'Модуль сделан каналом @mescr_m и желаю удачи вам в написании своих модулей :)',
        'text5': 'Кажется, я делаю это не в первый раз...'
    }

    def __init__(self): # Это конфиг. Аналог базы данных, но пользовать может напрямую влиять на любое значение конфига.
        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "random_int", # Указываем "ключ" по которому будет доступно значение из этого конфига.
                True, # Значение, которое мы присваиваем этому конфигу
                lambda: self.strings("random_int"), # Задаем описание конфига, используем self.strings, чтобы давать описание конфигу на нескольких языках
                validator=loader.validators.Boolean() # Выбираем тип значения. Чаще всего используется: Integer - целочисленное, Float - дробное, Boolean - True/False и Series - список. Об остальных вы можете почитать в офф. документации
            ),
        )

    async def client_ready(self): # Эта функция запускается автоматически при загрузке модуля или запуске юзербота
        self.set( # Здесь мы установим значение в базу данных...
            'key', # Указываем ключ
            False, # Значение, которое мы присовоим
        ) if self.get('key') == None else None # Мы настроили одну "ячейку" базы данных для использования

    @loader.command(
        alias = 'ncommand', # Задаем алиас команде. Алиас позволяет сразу задать одной функции несколько команд для ее выполнения
        ru_doc = '- выполнить эту команду' # Задаем описание для команды на русском языке 
    )
    async def nullcommand(self, message): # Можем указать просто message, hikka сама задаст ему объект сообщения при вызове функции
        '''- run this command''' # Задаем стандартное описание команде, в нашем случае, оно будет на англ. языке, хотя применится ко всем языкам, кроме русского
        
        # Начнем с текста для вывода сообщения
        text = f'<emoji document_id=5188377234380954537>🌘</emoji>' # Указываем ID премиум эмоджи. Если у пользователя будет Telegram Premium, то он увидит анимированную луну, иначе - эмоджи, указаный между HTML тегов 
        text += f'<b> {self.strings("text1")}.</b>\n\n' # Для форматирования текста используем HTML теги.
        
        # Теперь перейдем к случайному числу, который можно включить/выключить в нашем конфиге
        if self.config['random_int']:
            text += self.strings('text2')
            
            # Получаем случайное число
            number = random.randint(0, 100) # Для использования библиотек не обязательно загружать их на ваш компьтер
            text += f'<code>{number}</code>\n\n'

        # Давайте теперь сделаем так, чтобы если человек, который использует команду, ответил на чье-либо сообщение, то наш модуль показал ID того самого человека.
        reply = await message.get_reply_message() # Пробуем получить объект сообщения, на которое ответили (оно будет равно None, если мы не ответили не на чье сообщение)
        if reply:

            # Получим ID человека, на чье сообщение мы ответили
            user_id = reply.from_id

            # Добавим теперь это в текст
            text += self.strings('text3').format(user_id = user_id)

        # Давайте наконец отправим наш текст!
        await utils.answer( # Используем utils.answer, оно удобнее, ведь если бот может изменить сообщение - он его меняет, если нет - отправляет новое
            message, # Указываем, что мы меняем
            text, # Задаем новый текст
        )

        # Ну и почему бы нам не изменить сообщение снова через 2 секунды?
        text += f'\n\n<emoji document_id=5449505950283078474>❤️</emoji> <b>{self.strings("text4")}</b>'
        await asyncio.sleep(2) # Используем именно asyncio, ведь time.sleep() заставляет заспать весь юзербот, а ни только эту команду
        await utils.answer(
            message,
            text
        )

        # Давайте добавим еще одну забавную фишку...
        
        if self.get('key'): # Если значение с ключем из базы данных равно True
            text += f'\n<emoji document_id=5235728802142759605>👀</emoji> {self.strings("text5")}'

            # Подождем еще 1 секунду...
            await asyncio.sleep(1)
            await utils.answer(
                message,
                text
            )
        self.set('key', True) # Присвоим нашему ключу значение True, чтобы в следующий раз наш модуль что-то заподозрил
        